{"id":460766095,"question_id":1229,"lang":"python3","lang_name":"Python3","time":"4Â years","timestamp":1614309501,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/460766095/","is_pending":"Not Pending","title":"Shortest Path with Alternating Colors","memory":"N/A","code":"import heapq\nfrom collections import defaultdict\nclass Solution:\n    def shortestAlternatingPaths(self, n: int, red_edges: List[List[int]], blue_edges: List[List[int]]) -> List[int]:\n        \n        red_graph = defaultdict(list)\n        blue_graph = defaultdict(list)\n        visited = set()\n        # edge : u, v\n        for u, v in red_edges:\n            red_graph[u].append(v)\n        for u, v in blue_edges:\n            blue_graph[u].append(v)\n        \n        # 0 : red, 1 : blue\n        \n        dist_red = [0 for i in range(n)]\n        dist_blue = [0 for i in range(n)]\n        \n        def helper(turn, dist , queue):\n            val = 0\n            # print(turn , dist, queue)\n            while queue:\n                temp = []\n                val += 1\n                \n                while queue:\n                    cur = queue.pop(0)\n                    if turn % 2 == 0:\n                        for neigh in red_graph[cur]:\n                            if ((cur, neigh, 0)) not in visited:\n                                if dist[neigh] == 0 and neigh != 0:\n                                    dist[neigh] = val\n                                    temp.append(neigh)\n                                    visited.add((cur, neigh,0))\n                                elif dist[neigh] != 0:\n                                    temp.append(neigh)\n                                    visited.add((cur, neigh,0))\n                    else:\n                        for neigh in blue_graph[cur]:\n                            if ((cur, neigh,1)) not in visited:\n                                if dist[neigh] == 0 and neigh != 0:\n                                    dist[neigh] = val\n                                    temp.append(neigh)\n                                    visited.add((cur, neigh,1))\n                                elif dist[neigh] != 0:\n                                    temp.append(neigh)\n                                    visited.add((cur, neigh,1))\n                            \n                    turn += 1\n\n                queue = temp\n        helper(0, dist_red, [0])\n        visited = set()\n        helper(1, dist_blue, [0])\n        for i in range(1,n):\n            temp = min(dist_red[i], dist_blue[i])\n            if max(dist_red[i], dist_blue[i]) == 0:\n                dist_red[i] = -1\n            elif temp == 0:\n                dist_red[i] = max(dist_red[i], dist_blue[i])\n            else:\n                dist_red[i] = temp\n        res = dist_red\n        return res","compare_result":"111111111111111111111111001101010101010000100000100000101000100000110010100000100000000000","title_slug":"shortest-path-with-alternating-colors","has_notes":false,"flag_type":1}