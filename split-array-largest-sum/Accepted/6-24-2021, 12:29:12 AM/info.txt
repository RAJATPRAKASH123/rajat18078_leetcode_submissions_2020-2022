{"id":512212624,"question_id":410,"lang":"python3","lang_name":"Python3","time":"3 years, 8 months","timestamp":1624474752,"status":10,"status_display":"Accepted","runtime":"40 ms","url":"/submissions/detail/512212624/","is_pending":"Not Pending","title":"Split Array Largest Sum","memory":"14.5 MB","code":"class Solution:\n    def splitArray(self, nums: List[int], m: int) -> int:\n        if m == len(nums):\n            return max(nums)\n        low, high = max(nums), sum(nums)\n\n        def checkIt(cur):\n            nonlocal m\n            parts = m\n            sum = 0\n            for i in range(len(nums)):\n                sum += nums[i]\n                if sum > cur:\n                    sum = nums[i]\n                    parts -= 1\n            if sum != 0:\n                parts -= 1\n            if parts < 0:\n                return False\n            return True\n\n        while low < high:\n            cur = (low + high)//2\n            if checkIt(cur):\n                high = cur\n            else:\n                low = cur + 1\n        return low\n'''\nJust share something like a trick or template for remembering about Binary Search.\n[I can't explain] , but this [trick] seems to work.\nI know we'd better understand the theory but this is just a trick for remembering.\nWhen using Binary Search, it looks like to find the first T or the last F in FFFFFTTTTTTTTTTTT.(T means TRUE while F means FALSE.)\n\nl <= r\nThis means l can be chosen, and r can be chosen i.e. [l, r]. (vec[0], ..., vec.back())\nFor example:\nFFFFFFTTTTTT\n↑..........↑\nl..........r\n[l,r]\nIf we want to find first T,\nwhen mid is FALSE, the first T must on the right, so l = mid +1;\nwhen mid is TRUE, just remember to do as we do in the simplest binary search such as finding a distinct number in an ascending array, i.e. r = mid-1;\nThen it will end like this:\n\nFFFFFTTTTTT\n....↑↑\n....rl\n(l points to the first T, and r points to the last F)\nSo, if we want to find the first TRUE, we return l. If we want to find the last FALSE, we return r.\nIt seems that the Binary Search partitions the array to two parts:\n[0,r] : F, [l, size-1] : T, and maybe that's why we update l and r in that way.\nCode maybe like this:\n\nint BinarySearch(){\n\twhile(l<=r){\n\t\tint mid = l + (r-l)/2;\n\t\tif(TRUE(mid)){\n\t\t\tr = mid -1;\n\t\t}\n\t\telse{\n\t\t\tl = mid + 1;\n\t\t}\n\t}\n\treturn l;// find the first T\n\t//return r;//find the last F\n}\nl < r\nThis means r can not be chosen, i.e. [l, r).(Think about vec.begin(), vec.end())\nFor example:\nFFFFFFTTTTTT\n↑...........↑\nl...........r\n[l,r)\nJust remember to do as we do in the simplest binary search such as finding a distinct number in an ascending array.\nIf we want to find first T,\nwhen mid is FALSE, so the first T must be on the right, l = mid+1;\nwhen mid is TRUE, r = mid;(because r can not be chosen.)(Just remember to do as we do in the simplest binary search such as finding a distinct number in an ascending array).\nThen it will end like this:\n\nFFFFTTTTTTT\n....↑\n....l&&r\n(l and r points to the first T)\nSo, if we want to find the first TRUE, we return l(or r); if we want to find the last FALSE, we return l-1(or r-1).\n[0,r) : F, [l, size) : T\nCode maybe like this:\n\nint BinarySearch(){\n    while(l<r){\n        int mid = l + (r-l)/2;\n        if(TRUE(mid)){\n    \t\tr =mid;\n        }\n        else{\n        \tl = mid +1;\n        }\n    }\n    return l;//find the first T\n\t//return l-1;//find the last F\n}\n'''\n'''\n[2,3,1,2,4,3]\n\n2  5  6  8  12  15\n\n\n5\n\n\n\n\n\n\n[7,2,5,10,8]  # sum = 32 -> \n2\n\ncur = (10 + 32)//2 = 21\n\n10 and 20 : (10+20)//2 = 15\n\n 7  9  14  24  32\n    \n'''\n    \n    \n\n    ","compare_result":"111111111111111111111111111111","title_slug":"split-array-largest-sum","has_notes":false,"flag_type":1}