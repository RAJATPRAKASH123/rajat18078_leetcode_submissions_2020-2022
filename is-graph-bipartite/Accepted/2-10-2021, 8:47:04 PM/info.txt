{"id":454460443,"question_id":801,"lang":"python3","lang_name":"Python3","time":"4Â years","timestamp":1612970224,"status":10,"status_display":"Accepted","runtime":"180 ms","url":"/submissions/detail/454460443/","is_pending":"Not Pending","title":"Is Graph Bipartite?","memory":"14.6 MB","code":"class Solution:\n    def isBipartite(self, graph: List[List[int]]) -> bool:\n        n = len(graph)\n                \n        def graph_coloring(i, colors):\n            queue = [i]\n            while queue:\n                temp = []\n                while queue:\n                    node = queue.pop()\n                    visited.add(node)\n                    for neighbour in graph[node]:\n                        if colors[neighbour] == -1:\n                            colors[neighbour] = abs(1 - colors[node])\n                            temp.append(neighbour)\n                        elif colors[neighbour] == colors[node]:\n                            return False\n                        else:\n                            continue\n\n                queue = temp\n            return True\n        \n        ans = True\n        visited = set()\n        for i in range(n):\n            if len(graph[i]) > 0 and (i not in visited):\n                colors = [-1 for i in range(n)]\n                ans = ans and graph_coloring(i, colors)\n        return ans\n        \n'''\ngraph : undirected\n\nEach node is an integer between 0 and graph.length - 1\n# Approach : \nsets -> A and B : 0 and 1 colors respectively\n\nfor \n'''\n","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"is-graph-bipartite","has_notes":false,"flag_type":1}