{"id":452157131,"question_id":684,"lang":"python3","lang_name":"Python3","time":"4Â years","timestamp":1612488233,"status":10,"status_display":"Accepted","runtime":"52 ms","url":"/submissions/detail/452157131/","is_pending":"Not Pending","title":"Redundant Connection","memory":"14.9 MB","code":"from collections import defaultdict\nclass Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        \n        parent = [0 for i in range(len(edges))]\n        \n        def find(x):\n            if parent[x] == 0:\n                return x\n            return find(parent[x])\n        \n        def union(x, y):\n            if find(x) == find(y):\n                return False\n            parent[find(x)] = find(y)\n            return True\n        \n        for x,y in edges:\n            if not union(x-1,y-1):\n                return [x,y]\n            \n        \n'''\n        n = len(edges)\n        count_connection = [0]*n\n        for i in edges:\n            count_connection[i[0]-1] += 1; count_connection[i[1]-1] += 1\n\n        if 1 not in count_connection:\n            return edges[-1]\n        \n        start = count_connection.index(1)+1\n        graph = defaultdict(list)\n        parent = defaultdict(int)\n        \n        for i in edges:\n            graph[i[0]].append(i[1]); graph[i[1]].append(i[0])\n        print(graph)\n        # Wrong assumption :we don't need visited here, parent array will work\n        # we need visited\n        visited = \n        def dfs(i):\n            for neighbour in graph[i]:\n                print(graph[i], neighbour, parent)\n                if neighbour not in parent:\n                    parent[neighbour] = i\n                    return dfs( neighbour)\n                else:\n                    return neighbour, i\n        print(start)\n        cycle_start, cycle_end = dfs(start)\n        print(parent)\n        # edges with cycle\n        cycle_edges = []\n        \n        while parent[cycle_end] != parent[cycle_start]:\n            cycle_edges.append([cycle_end, parent[cycle_end]])\n            cycle_end = parent[cycle_end]\n        print(cycle_edges)\n        for i in edges[::-1]:\n            if [i[0],i[1]] in cycle_edges or [i[1],i[0]] in cycle_edges:\n                return i\n        \n'''         \n        \n'''\nundirected graph\nn nodes\n\nwe can detect the nodes via traversing through bfs : My Idea\nAfter seeing a post : Use Union Find\n\nLet's try to implement Union Find\n[None, 1, 1, 1, 1, ]\nI am not liking it.\n\nI can see an approach through dfs : \n1. Find an element, i.e. it is connected with only 1 node, if couldn't find one,\n    just return max\n2. I found, start a dfs from corresponding vertex, while keeping track of its parent\n3. When, any visited node revisited, we got our cycle, get ans from it.\n'''","compare_result":"111111111111111111111111111111111111111","title_slug":"redundant-connection","has_notes":false,"flag_type":1}