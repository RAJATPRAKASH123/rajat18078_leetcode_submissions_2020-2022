{"id":456472694,"question_id":1218,"lang":"python3","lang_name":"Python3","time":"4Â years","timestamp":1613422166,"status":10,"status_display":"Accepted","runtime":"52 ms","url":"/submissions/detail/456472694/","is_pending":"Not Pending","title":"Lowest Common Ancestor of Deepest Leaves","memory":"14.5 MB","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def lcaDeepestLeaves(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return root\n        if root.left is None and root.right is None:\n            return root\n        #simple BFS\n        queue = [root]\n        dist = defaultdict(list)\n        num_nodes = 0\n        while queue:\n            temp = []\n            while queue:\n                node = queue.pop(0)\n                if node.left:\n                    temp.append(node.left)\n                if node.right:\n                    temp.append(node.right)\n            queue = temp\n            num_nodes += 1\n            if temp:\n                dist[num_nodes] += [temp[0], temp[-1]]\n        maxm = max(dist.keys())\n        \n        deep_nodes = dist[maxm]\n        \n        def lca(root):\n            if not root:\n                return None\n            for i in deep_nodes:\n                if i.val == root.val:\n                    return root\n            l, r = lca(root.left), lca(root.right)\n            if l is not None and r is not None:\n                return root\n            if l is not None:\n                return l\n            if r is not None:\n                return r\n            return None\n        return lca(root)","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"lowest-common-ancestor-of-deepest-leaves","has_notes":false,"flag_type":1}