{"id":456469414,"question_id":896,"lang":"python3","lang_name":"Python3","time":"4Â years","timestamp":1613421601,"status":10,"status_display":"Accepted","runtime":"2716 ms","url":"/submissions/detail/456469414/","is_pending":"Not Pending","title":"Smallest Subtree with all the Deepest Nodes","memory":"14.3 MB","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom collections import defaultdict\nclass Solution:\n    def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return root\n        if root.left is None and root.right is None:\n            return root\n        #simple BFS\n        queue = [root]\n        dist = defaultdict(list)\n        num_nodes = 0\n        while queue:\n            temp = []\n            while queue:\n                node = queue.pop(0)\n                if node.left:\n                    temp.append(node.left)\n                if node.right:\n                    temp.append(node.right)\n            queue = temp\n            num_nodes += 1\n            if temp:\n                dist[num_nodes] += temp\n        maxm = max(dist.keys())\n        \n        deep_nodes = dist[maxm]\n        \n        def lca(root):\n            if not root:\n                return None\n            for i in deep_nodes:\n                if i.val == root.val:\n                    return root\n            l, r = lca(root.left), lca(root.right)\n            if l is not None and r is not None:\n                return root\n            if l is not None:\n                return lca(root.left)\n            if r is not None:\n                return lca(root.right)\n            return None\n        return lca(root)\n'''\nMy thoughts :\n1. BFS and maintain a distance array\n2. Find LCA of those which have max distance\n    a) Search for all node values in left and right nodes\n        if found in left and right implies we have our ans \n        else: if found_in(left) return left ans\n        else: return right ans\n'''","compare_result":"1111111111111111111111111111111111111111111111111111111111","title_slug":"smallest-subtree-with-all-the-deepest-nodes","has_notes":false,"flag_type":1}